// SPDX-License-Identifier: MPL-2.0

package provider

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/polarsource/polar-go"
	"github.com/polarsource/polar-go/models/apierrors"
	"github.com/polarsource/polar-go/models/components"
)

var _ resource.Resource = &WebhookEndpointResource{}
var _ resource.ResourceWithImportState = &WebhookEndpointResource{}

func NewWebhookEndpointResource() resource.Resource {
	return &WebhookEndpointResource{}
}

type WebhookEndpointResource struct {
	client *polargo.Polar
}

type WebhookEndpointResourceModel struct {
	ID             types.String `tfsdk:"id"`
	URL            types.String `tfsdk:"url"`
	Format         types.String `tfsdk:"format"`
	Events         types.Set    `tfsdk:"events"`
	Secret         types.String `tfsdk:"secret"`
	Enabled        types.Bool   `tfsdk:"enabled"`
	OrganizationID types.String `tfsdk:"organization_id"`
	CreatedAt      types.String `tfsdk:"created_at"`
	ModifiedAt     types.String `tfsdk:"modified_at"`
}

func (r *WebhookEndpointResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_webhook_endpoint"
}

func (r *WebhookEndpointResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a Polar webhook endpoint. Webhook endpoints receive event notifications via HTTP POST requests.",

		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				MarkdownDescription: "The webhook endpoint ID.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"url": schema.StringAttribute{
				MarkdownDescription: "The URL where webhook events will be sent.",
				Required:            true,
			},
			"format": schema.StringAttribute{
				MarkdownDescription: "The format of webhook payloads. Must be `raw`, `discord`, or `slack`.",
				Required:            true,
				Validators: []validator.String{
					stringvalidator.OneOf("raw", "discord", "slack"),
				},
			},
			"events": schema.SetAttribute{
				MarkdownDescription: "The set of event types this endpoint subscribes to.",
				Required:            true,
				ElementType:         types.StringType,
			},
			"secret": schema.StringAttribute{
				MarkdownDescription: "The HMAC secret used to sign webhook payloads. Generated by the server on creation.",
				Computed:            true,
				Sensitive:           true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"enabled": schema.BoolAttribute{
				MarkdownDescription: "Whether the webhook endpoint is enabled. Defaults to `true`.",
				Optional:            true,
				Computed:            true,
				Default:             booldefault.StaticBool(true),
			},
			"organization_id": schema.StringAttribute{
				MarkdownDescription: "The organization ID that owns this webhook endpoint.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"created_at": schema.StringAttribute{
				MarkdownDescription: "Timestamp when the webhook endpoint was created.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"modified_at": schema.StringAttribute{
				MarkdownDescription: "Timestamp when the webhook endpoint was last modified.",
				Computed:            true,
			},
		},
	}
}

func (r *WebhookEndpointResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*polargo.Polar)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *polargo.Polar, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}

	r.client = client
}

func (r *WebhookEndpointResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data WebhookEndpointResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Convert events from Terraform set to SDK type
	var eventStrings []string
	resp.Diagnostics.Append(data.Events.ElementsAs(ctx, &eventStrings, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	events := make([]components.WebhookEventType, len(eventStrings))
	for i, e := range eventStrings {
		events[i] = components.WebhookEventType(e)
	}

	createReq := components.WebhookEndpointCreate{
		URL:    data.URL.ValueString(),
		Format: components.WebhookFormat(data.Format.ValueString()),
		Events: events,
	}

	result, err := r.client.Webhooks.CreateWebhookEndpoint(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error creating webhook endpoint",
			fmt.Sprintf("Could not create webhook endpoint: %s", err),
		)
		return
	}

	tflog.Trace(ctx, "created webhook endpoint", map[string]interface{}{
		"id": result.WebhookEndpoint.ID,
	})

	endpoint := result.WebhookEndpoint

	// The Create API always creates endpoints as enabled.
	// If the user requested enabled = false, do a follow-up update.
	if !data.Enabled.IsNull() && !data.Enabled.ValueBool() {
		enabled := false
		updateResult, err := r.client.Webhooks.UpdateWebhookEndpoint(ctx, endpoint.ID, components.WebhookEndpointUpdate{
			Enabled: &enabled,
		})
		if err != nil {
			resp.Diagnostics.AddError(
				"Error disabling webhook endpoint after creation",
				fmt.Sprintf("Webhook endpoint %s was created but could not be disabled: %s", endpoint.ID, err),
			)
			return
		}
		endpoint = updateResult.WebhookEndpoint
	}

	// Map response to state
	r.mapResponseToState(ctx, endpoint, &data, &resp.Diagnostics)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WebhookEndpointResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data WebhookEndpointResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	result, err := r.client.Webhooks.GetWebhookEndpoint(ctx, data.ID.ValueString())
	if err != nil {
		// If the resource no longer exists, remove it from state
		var notFound *apierrors.ResourceNotFound
		if isNotFound(err, &notFound) {
			tflog.Trace(ctx, "webhook endpoint not found, removing from state", map[string]interface{}{
				"id": data.ID.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError(
			"Error reading webhook endpoint",
			fmt.Sprintf("Could not read webhook endpoint %s: %s", data.ID.ValueString(), err),
		)
		return
	}

	r.mapResponseToState(ctx, result.WebhookEndpoint, &data, &resp.Diagnostics)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WebhookEndpointResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data WebhookEndpointResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Convert events from Terraform set to SDK type
	var eventStrings []string
	resp.Diagnostics.Append(data.Events.ElementsAs(ctx, &eventStrings, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	events := make([]components.WebhookEventType, len(eventStrings))
	for i, e := range eventStrings {
		events[i] = components.WebhookEventType(e)
	}

	url := data.URL.ValueString()
	format := components.WebhookFormat(data.Format.ValueString())
	enabled := data.Enabled.ValueBool()

	updateReq := components.WebhookEndpointUpdate{
		URL:     &url,
		Format:  &format,
		Events:  events,
		Enabled: &enabled,
	}

	result, err := r.client.Webhooks.UpdateWebhookEndpoint(ctx, data.ID.ValueString(), updateReq)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error updating webhook endpoint",
			fmt.Sprintf("Could not update webhook endpoint %s: %s", data.ID.ValueString(), err),
		)
		return
	}

	r.mapResponseToState(ctx, result.WebhookEndpoint, &data, &resp.Diagnostics)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WebhookEndpointResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data WebhookEndpointResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	_, err := r.client.Webhooks.DeleteWebhookEndpoint(ctx, data.ID.ValueString())
	if err != nil {
		// If already deleted, that's fine
		var notFound *apierrors.ResourceNotFound
		if isNotFound(err, &notFound) {
			return
		}
		resp.Diagnostics.AddError(
			"Error deleting webhook endpoint",
			fmt.Sprintf("Could not delete webhook endpoint %s: %s", data.ID.ValueString(), err),
		)
		return
	}

	tflog.Trace(ctx, "deleted webhook endpoint", map[string]interface{}{
		"id": data.ID.ValueString(),
	})
}

func (r *WebhookEndpointResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}

// mapResponseToState maps a WebhookEndpoint API response to the Terraform resource model.
func (r *WebhookEndpointResource) mapResponseToState(ctx context.Context, endpoint *components.WebhookEndpoint, data *WebhookEndpointResourceModel, diags *diag.Diagnostics) {
	data.ID = types.StringValue(endpoint.ID)
	data.URL = types.StringValue(endpoint.URL)
	data.Format = types.StringValue(string(endpoint.Format))
	data.Secret = types.StringValue(endpoint.Secret)
	data.Enabled = types.BoolValue(endpoint.Enabled)
	data.OrganizationID = types.StringValue(endpoint.OrganizationID)
	data.CreatedAt = types.StringValue(endpoint.CreatedAt.Format(time.RFC3339))

	if endpoint.ModifiedAt != nil {
		data.ModifiedAt = types.StringValue(endpoint.ModifiedAt.Format(time.RFC3339))
	} else {
		data.ModifiedAt = types.StringNull()
	}

	// Convert events to Terraform set
	eventValues := make([]attr.Value, len(endpoint.Events))
	for i, e := range endpoint.Events {
		eventValues[i] = types.StringValue(string(e))
	}
	eventsSet, setDiags := types.SetValue(types.StringType, eventValues)
	diags.Append(setDiags...)
	data.Events = eventsSet
}

// isNotFound checks if an error is a Polar API 404 ResourceNotFound error.
func isNotFound(err error, target **apierrors.ResourceNotFound) bool {
	return errors.As(err, target)
}
