// SPDX-License-Identifier: MPL-2.0

package provider

import (
	"context"
	"fmt"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/polarsource/polar-go"
	"github.com/polarsource/polar-go/models/components"
)

// Compile-time interface conformance checks.
var _ resource.Resource = &WebhookEndpointResource{}
var _ resource.ResourceWithImportState = &WebhookEndpointResource{}

func NewWebhookEndpointResource() resource.Resource {
	return &WebhookEndpointResource{}
}

type WebhookEndpointResource struct {
	client *polargo.Polar // set in Configure()
}

// WebhookEndpointResourceModel is the Terraform state shape for polar_webhook_endpoint.
type WebhookEndpointResourceModel struct {
	ID      types.String `tfsdk:"id"`
	URL     types.String `tfsdk:"url"`
	Format  types.String `tfsdk:"format"`
	Events  types.Set    `tfsdk:"events"`
	Secret  types.String `tfsdk:"secret"`
	Enabled types.Bool   `tfsdk:"enabled"`
}

func (r *WebhookEndpointResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_webhook_endpoint"
}

func (r *WebhookEndpointResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a Polar webhook endpoint. Webhook endpoints receive event notifications via HTTP POST requests.",

		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				MarkdownDescription: "The webhook endpoint ID.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"url": schema.StringAttribute{
				MarkdownDescription: "The URL where webhook events will be sent. Must use HTTPS.",
				Required:            true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(
						regexp.MustCompile(`^https://`),
						"webhook URL must use HTTPS to protect payload confidentiality",
					),
				},
			},
			"format": schema.StringAttribute{
				MarkdownDescription: "The format of webhook payloads. Must be `raw`, `discord`, or `slack`.",
				Required:            true,
				Validators: []validator.String{
					stringvalidator.OneOf("raw", "discord", "slack"),
				},
			},
			"events": schema.SetAttribute{
				MarkdownDescription: "The set of event types this endpoint subscribes to.",
				Required:            true,
				ElementType:         types.StringType,
			},
			"secret": schema.StringAttribute{
				MarkdownDescription: "The HMAC secret used to sign webhook payloads. Generated by the server on creation.",
				Computed:            true,
				Sensitive:           true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"enabled": schema.BoolAttribute{
				MarkdownDescription: "Whether the webhook endpoint is enabled. Defaults to `true`.",
				Optional:            true,
				Computed:            true,
				Default:             booldefault.StaticBool(true),
			},
		},
	}
}

func (r *WebhookEndpointResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if pd := extractProviderData(req.ProviderData, &resp.Diagnostics); pd != nil {
		r.client = pd.Client
	}
}

func (r *WebhookEndpointResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data WebhookEndpointResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Convert events from Terraform set to SDK type
	var eventStrings []string
	resp.Diagnostics.Append(data.Events.ElementsAs(ctx, &eventStrings, false)...)
	if resp.Diagnostics.HasError() {
		return
	}

	events := make([]components.WebhookEventType, len(eventStrings))
	for i, e := range eventStrings {
		events[i] = components.WebhookEventType(e)
	}

	createReq := components.WebhookEndpointCreate{
		URL:    data.URL.ValueString(),
		Format: components.WebhookFormat(data.Format.ValueString()),
		Events: events,
	}

	result, err := r.client.Webhooks.CreateWebhookEndpoint(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error creating webhook endpoint",
			fmt.Sprintf("Could not create webhook endpoint: %s", err),
		)
		return
	}

	tflog.Trace(ctx, "created webhook endpoint", map[string]interface{}{
		"id": result.WebhookEndpoint.ID,
	})

	endpoint := result.WebhookEndpoint

	// The Create API always creates endpoints as enabled.
	// If the user requested enabled = false, do a follow-up update.
	if !data.Enabled.IsNull() && !data.Enabled.ValueBool() {
		enabled := false
		updateResult, err := r.client.Webhooks.UpdateWebhookEndpoint(ctx, endpoint.ID, components.WebhookEndpointUpdate{
			Enabled: &enabled,
		})
		if err != nil {
			resp.Diagnostics.AddError(
				"Error disabling webhook endpoint after creation",
				fmt.Sprintf("Webhook endpoint %s was created but could not be disabled: %s", endpoint.ID, err),
			)
			return
		}
		endpoint = updateResult.WebhookEndpoint
	}

	// Polar's API is eventually consistent — a successful write may not be
	// reflected by the next read. We extract the write timestamp from the API
	// response (not local clock) and poll GET until the response timestamp
	// catches up, confirming the write has propagated across replicas.
	writeTime := latestTimestamp(endpoint)
	webhook, err := pollForConsistency(ctx, "webhook endpoint", endpoint.ID, writeTime, func() (*components.WebhookEndpoint, error) {
		result, err := r.client.Webhooks.GetWebhookEndpoint(ctx, endpoint.ID)
		if err != nil {
			return nil, err
		}
		return result.WebhookEndpoint, nil
	}, &resp.Diagnostics)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error waiting for webhook endpoint visibility",
			fmt.Sprintf("Webhook endpoint %s was created but not immediately readable: %s", endpoint.ID, err),
		)
		return
	}

	// Map the consistent API response → TF model and persist to state.
	r.mapResponseToState(ctx, webhook, &data, &resp.Diagnostics)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Read refreshes TF state from the API. If the resource was deleted out-of-band
// (404), it's gracefully removed from state so Terraform knows to recreate it.
func (r *WebhookEndpointResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data WebhookEndpointResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	result, err := r.client.Webhooks.GetWebhookEndpoint(ctx, data.ID.ValueString())
	if err != nil {
		if handleNotFoundRemove(ctx, err, "webhook endpoint", data.ID.ValueString(), &resp.State) {
			return
		}
		resp.Diagnostics.AddError(
			"Error reading webhook endpoint",
			fmt.Sprintf("Could not read webhook endpoint %s: %s", data.ID.ValueString(), err),
		)
		return
	}

	r.mapResponseToState(ctx, result.WebhookEndpoint, &data, &resp.Diagnostics)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Update: plan → build SDK request → call API → poll for consistency → save state.
func (r *WebhookEndpointResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data WebhookEndpointResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Convert TF set → SDK event types.
	var eventStrings []string
	resp.Diagnostics.Append(data.Events.ElementsAs(ctx, &eventStrings, false)...)
	if resp.Diagnostics.HasError() {
		return
	}
	events := make([]components.WebhookEventType, len(eventStrings))
	for i, e := range eventStrings {
		events[i] = components.WebhookEventType(e)
	}

	url := data.URL.ValueString()
	format := components.WebhookFormat(data.Format.ValueString())
	enabled := data.Enabled.ValueBool()

	updateReq := components.WebhookEndpointUpdate{
		URL:     &url,
		Format:  &format,
		Events:  events,
		Enabled: &enabled,
	}

	updateResult, err := r.client.Webhooks.UpdateWebhookEndpoint(ctx, data.ID.ValueString(), updateReq)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error updating webhook endpoint",
			fmt.Sprintf("Could not update webhook endpoint %s: %s", data.ID.ValueString(), err),
		)
		return
	}

	// Eventual consistency poll (same pattern as Create).
	webhookID := data.ID.ValueString()
	writeTime := latestTimestamp(updateResult.WebhookEndpoint)
	webhook, err := pollForConsistency(ctx, "webhook endpoint", webhookID, writeTime, func() (*components.WebhookEndpoint, error) {
		result, err := r.client.Webhooks.GetWebhookEndpoint(ctx, webhookID)
		if err != nil {
			return nil, err
		}
		return result.WebhookEndpoint, nil
	}, &resp.Diagnostics)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reading webhook endpoint after update",
			fmt.Sprintf("Could not read webhook endpoint %s: %s", webhookID, err),
		)
		return
	}

	r.mapResponseToState(ctx, webhook, &data, &resp.Diagnostics)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

// Delete performs a real DELETE (unlike meters/products which archive).
// If the resource was already deleted out-of-band (404), that's a no-op.
func (r *WebhookEndpointResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data WebhookEndpointResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	_, err := r.client.Webhooks.DeleteWebhookEndpoint(ctx, data.ID.ValueString())
	if err != nil {
		if isNotFound(err) {
			return
		}
		resp.Diagnostics.AddError(
			"Error deleting webhook endpoint",
			fmt.Sprintf("Could not delete webhook endpoint %s: %s", data.ID.ValueString(), err),
		)
		return
	}

	tflog.Trace(ctx, "deleted webhook endpoint", map[string]interface{}{
		"id": data.ID.ValueString(),
	})
}

func (r *WebhookEndpointResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}

// mapResponseToState maps a WebhookEndpoint API response to the Terraform resource model.
func (r *WebhookEndpointResource) mapResponseToState(ctx context.Context, endpoint *components.WebhookEndpoint, data *WebhookEndpointResourceModel, diags *diag.Diagnostics) {
	data.ID = types.StringValue(endpoint.ID)
	data.URL = types.StringValue(endpoint.URL)
	data.Format = types.StringValue(string(endpoint.Format))
	data.Secret = types.StringValue(endpoint.Secret)
	data.Enabled = types.BoolValue(endpoint.Enabled)

	// Convert events to Terraform set
	eventValues := make([]attr.Value, len(endpoint.Events))
	for i, e := range endpoint.Events {
		eventValues[i] = types.StringValue(string(e))
	}
	eventsSet, setDiags := types.SetValue(types.StringType, eventValues)
	diags.Append(setDiags...)
	data.Events = eventsSet
}
